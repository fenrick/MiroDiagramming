Board UI Jump to Content Documentation Resources Marketplace Community Documentation API Reference Changelog v2.0 Documentation Resources Marketplace Community Build your app Documentation Build your app Moon (Dark Mode) Sun (Light Mode) main Documentation Board UI Board UI Search Platform Essentials Introduction Web SDK vs REST API Getting started Developer team Create a Developer team Change the Developer team name Delete the Developer team Migrating a developer app App manifest Concepts Boards Board items Children inside parent items App card App card use cases Edit, update, and keep app cards synced Backend flow for app cards Enable REST API authentication from Miro&#x27;s Web SDK authorization Enable 2-way sync between app cards and GitHub cards Card Connector Embed Events Frame Image Mind map (Experimental) Preview Shape Sticky note Storage Text Tag Migrate from v1 to v2 Web SDK comparison guide Web SDK reference guide REST API comparison guide REST API reference guide Web SDK Introduction Miro Web SDK and board items App panels and modals Guided onboarding Onboarding essentials 1) Create your first board item with the Web SDK 2) Update an item&#x27;s properties with `sync()` 3) Run your first app in Miro 4) Interact with your app in Miro 5) Join the conversation 6) Install a Marketplace app 7) Add Mirotone to an existing app Onboarding wrap-up Challenge: Where&#x27;s Miro? Submit and share your app 1) Share an app outside of a developer team 2) Understand app submission requirements 3) Publish a Miro app 4) Share your ideas with us Submit and share wrap-up In-depth training modules 1) Create your 1st Miro app locally 2) Build a full-stack Miro app Getting started Quickstart Video: try the Web SDK in less than 1 minute Build your first Hello World app Build a Web SDK app Build a REST API app Build a full-stack (Next.js) app Enable running apps as instant apps How-Tos &amp; tutorials Use the browser developer tools with the Miro Web SDK Update and sync item properties Add icon click to your app Add an icon to your app Add drag and drop to your app Add permission scopes to your app Add search and filter to your app Build a calendar app in Miro Convert sticky notes to shapes Create mind map from CSV Add custom actions to your app Deploy a Miro app Log in to a third-party service using OAuth Enable 2-way sync between app cards and GitHub cards Enable REST API authentication from Miro&#x27;s Web SDK authorization Integrate a digital asset manager in Miro Convert frame coordinates to board coordinates SVG app icon optimization guidelines Upload images and SVGs as base64-encoded strings Connect the Miro Web SDK to a backend (Firebase) Video: Deploy a Next.js App on AWS Amplify Video: Integrate OpenAI + Miro Build collaborative app experiences Display banner/modal on a Miro board using DynamoDB Display banner/modal on a Miro board using AWS S3 Reference Interact with boards and items Rate limiting Error handling Board Card Board UI Viewport Notifications App card Experimental Realtime Events Tag Custom Action Management Shape Frame Image Sticky Note Shape experimental Embed Connector Unsupported Mindmap Node Preview Text Storage collection Storage Collaboration Session Attention Group History REST API Introduction Getting started Quickstart Video: try the REST API in less than 3 minutes Access Enterprise APIs Build your first Hello World REST API app Getting started with webhooks Webhooks using Python How-To&#x27;s &amp; tutorials Get started with OAuth 2.0 and Miro Enable REST API authentication from Miro&#x27;s Web SDK authorization Access Enterprise APIs Create sticky notes and tags Convert code to diagram with Miro PlantUML Get user info and email Create an image from a data URL source Work with connectors Securely manage boards and teams at scale Enable 2-way sync between app cards and GitHub cards Set up a test endpoint for webhooks with Pipedream Troubleshoot OAuth2.0 Video: OAuth Essentials for Frontenders Miro Node.js client Miro Node.js client Readme Miro Node.js client quickstart for task automation Miro Node.js client quickstart with OAuth and Express Implement data storage Reference documentation Miro Python client Reference Marketplace Miro Marketplace Get ready for Marketplace App design guidelines App security guidelines App development policy App listing guidelines Build and deploy your app Your Marketplace profile Publish your app Monetization Monetization with Miro + Stripe Monetization with Miro + Salable Provide pricing details for your app Developer benefits App Metrics SCIM API Introduction User lifecycle management Getting started Concepts Rate limits Errors Reference Users Groups Discovery features Live Embed Introduction Getting started Authentication oEmbed support How-Tos &amp; tutorials Live Embed with a direct link Live Embed view-only mode Live Embed with BoardsPicker for registered users Live Embed with BoardsPicker for unregistered users Reference Resources Resources overview Changelog Roadmap Mirotone Miro app examples Miro Postman —Åollection Policies Developer terms of use App development policy Lifecycle policy Deprecation policy Board UI Methods canOpenPanel(...) () =&gt; Promise&lt;boolean&gt; Checks if there are blocking elements before attempting to open a panel in the UI. Panels that are already open from other sources can block these requests. It&#x27;s recommended to check using miro.board.ui.canOpenPanel before using miro.board.ui.openPanel . Example: TypeScript if (await miro.board.ui.canOpenPanel()) { await miro.board.ui.openPanel({ url: &#x27;show-this-page-in-the-panel.html&#x27;, height: 400, }); } openPanel(...) ( options: Identity&lt;{ height ?: number; title =&quot;url&quot;&gt;url: string } &amp; conditional&gt; ) =&gt; Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt; Opens a panel on the current board. The content displayed in the panel is fetched from the specified URL. The panel height corresponds to the current viewport height. Panel width: currently it&#x27;s set to 368 dp , fixed, padding included. You should implement your app to adapt to content area width changes between 292 dp and 320 dp, and to accommodate a fixed panel width between 340 dp and 368 dp, padding included. Left padding: 24 dp Right padding: 24 dp When opening a panel, you can pass in data that can be accessed within the panel itself. Use the data property within the options object to pass the necessary information. Note : To get the data from inside the panel, use getPanelData() method. The method for opening the panel returns a Promise . This Promise resolves to an object that includes a waitForClose() method: TypeScript Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt;; The waitForClose() method returns a Promise that resolves to the result of the panel when it&#x27;s closed, or undefined if there is no result. The result is a value that is passed as a parameter into closePanel() method. Note : When a user manually closes a panel, the promise returned by the waitForClose() method always resolves with an undefined value. Example: TypeScript // Example 1: Basic usage of openPanel await miro.board.ui.openPanel({ url: &#x27;show-this-page-in-the-panel.html&#x27;, }); // The panel is displayed on the board // Example 2: Passing data into the panel const dataForModal = &quot;hello world&quot;; await miro.board.ui.openPanel&lt;string&gt;({ data: dataForModal, url: &#x27;show-this-page-in-the-panel.html&#x27;, }); // Example 3: Waiting for the panel to close const someData = { message: &quot;my message&quot; }; const { waitForClose } = await miro.board.ui.openPanel&lt;{message: string}, string&gt;({ data: someData, url: &#x27;show-this-page-in-the-panel.html&#x27;, }); // Inside the panel, you can call the following to close the panel and resolve the Promise: // await miro.board.ui.closePanel(&#x27;result&#x27;); console.log(await waitForClose()); // This will log: &quot;result&quot; The content that apps display on modals and panels opens inside iframes. iframes can request access to the following permissions : microphone:listen : access a user&#x27;s microphone to record audio in an iframe. screen:record : access a user&#x27;s screen to record it in an iframe. webcam:record : access a user&#x27;s camera to record video. See also: Add permission scopes to your app Name Type Description options object - options.url string Absolute or relative URL pointing to the content that you want to display in the panel. If you specify a relative URL, the URL path resolves relative to the app URL. The transport protocol must be HTTPS. options.data? any Any data that you want to pass directly to the panel and use it inside the panel itself. Check the getPanelData() method. getPanelData(...) () =&gt; Promise&lt;undefined | Data&gt; Retrieves the data associated with the currently open panel in the Miro board. This data is initially passed to the panel when it is opened using the miro.board.ui.openPanel({ data, ... }) method. This method is typically called from within the panel itself to access any data that it needs to function correctly. If no data was passed when the panel was opened, calling getPanelData will return a promise that resolves to undefined . Note: getPanelData will always return promise that resolves or to undefined or to the actual passed data. Example: Consider the following scenario where a panel is opened with some data: TypeScript // Define some data to pass to the panel const someData = { message: &quot;my message&quot; }; // Open a panel and pass the data to it const { waitForClose } = await miro.board.ui.openPanel&lt;{message: string}, string&gt;({ data: someData, url: &#x27;show-this-page-in-the-panel.html&#x27;, height: 400, }); Now, from within the panel, you can retrieve this data using getPanelData() : TypeScript // Retrieve the data from within the panel const data = await miro.board.ui.getPanelData&lt;{message: string}&gt;() console.log(data) // Outputs: &quot;{ message: &quot;my message&quot; }&quot; closePanel(...) (result?: Result) =&gt; Promise&lt;void&gt; Closes an open panel on the current board. This method accepts an optional result parameter. Providing this parameter results in the panel being resolved with the provided value. If you use the waitForClose() method‚Äîreturned by the miro.board.ui.openPanel(...) ‚Äîthe promise returned by waitForClose() will resolve, returning the value of result . TLDR; If you&#x27;ve passed a result value and close the panel, this value will be returned by the waitForClose() promise. This is useful if you want to perform some action based on the result after the panel is closed. ‚ÑπÔ∏è Note: To close an open panel, closePanel must be executed after openPanel . The app that closes the panel with closePanel must be the same that opened it with openPanel . Example: TypeScript // Open a panel await miro.board.ui.openPanel({ url: &#x27;show-this-page-in-the-panel.html&#x27;, height: 400, }); // Close the open panel await miro.board.ui.closePanel(); // Open a panel and wait for the result const {waitForClose} = await miro.board.ui.openPanel({ url: &#x27;show-this-page-in-the-panel.html&#x27;, height: 400, }); async function logResult() { const result = await waitForClose(); console.log(result) // This will log: &quot;Hello world!&quot; } logResult() // Close the open panel with some result await miro.board.ui.closePanel(&quot;Hello world!&quot;); The content that apps display on modals and panels opens inside iframes. iframes can request access to the following permissions : microphone:listen : access a user&#x27;s microphone to record audio in an iframe. screen:record : access a user&#x27;s screen to record it in an iframe. webcam:record : access a user&#x27;s camera to record video. See also: Add permission scopes to your app canOpenModal(...) () =&gt; Promise&lt;boolean&gt; Checks if there are blocking elements before attempting to open a model in the UI. Modals are blocking elements, meaning there can be only one modal displayed at a time for a user. If your operation happens at the same time as another Miro modal is being shown, your modal won&#x27;t be displayed to the user. It&#x27;s recommended to check using miro.board.ui.canOpenModal before using miro.board.ui.openModal . Example: TypeScript if (await miro.board.ui.canOpenModal()) { await miro.board.ui.openModal({ url: &#x27;show-this-page-in-the-modal.html&#x27;, width: 600, height: 400, fullscreen: false, }); } openModal(...) ( options: Identity&lt;{ fullscreen?: boolean; height ?: number; title =&quot;url&quot;&gt;url: string; width ?: number } &amp; conditional&gt; ) =&gt; Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt; Opens a modal on the current board. The content displayed in the modal is fetched from the specified URL. The max. width and height of the modal correspond to the width and height of the current viewport. The load timeout for the modal is 10 seconds. You have the ability to pass data into a modal that you open. This data can then be accessed from within the modal itself. To pass data, use the data property in the options object when opening it. Note: to get the data from inside the modal you have to use getModalData() method. The method for opening the modal returns a Promise . This Promise resolves to an object that includes a waitForClose() method: TypeScript Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt;; The waitForClose() method returns a Promise that resolves to the result of the modal when it&#x27;s closed, or undefined if there is no result. The result is a value that is passed as a parameter into closeModal() method. Note: promise returned by waitForClose() method will always be resolved with undefined value in case of manual closing of modal by user. Example: TypeScript // Example 1: Basic usage of openModal await miro.board.ui.openModal({ url: &quot;show-this-page-in-the-modal.html&quot;, width: 600, height: 400, fullscreen: false, }); // This will open a modal with the specified URL, width, and height. The modal will not be displayed in fullscreen mode. // Example 2: Passing data into the modal const dataForModal = &quot;hello world&quot;; await miro.board.ui.openModal&lt;string&gt;({ data: dataForModal, url: &quot;show-this-page-in-the-modal.html&quot;, width: 600, height: 400, fullscreen: false, }); // Example 3: Waiting for the modal to close const someData = { message: &quot;my message&quot; }; const { waitForClose } = await miro.board.ui.openModal&lt;{message: string}, string&gt;({ data: someData, url: &quot;show-this-page-in-the-modal.html&quot;, width: 600, height: 400, fullscreen: false, }); // Inside the modal, you can call the following to close the modal and resolve the Promise: // await miro.board.ui.closeModal(&#x27;result&#x27;); console.log(await waitForClose()); // This will log: &quot;result&quot; Name Type Description options object - options.url string Absolute or relative URL pointing to the content that you want to display in the panel. If you specify a relative URL, the URL path resolves relative to the app URL. The transport protocol must be HTTPS. options.height? number Sets the height of the modal, in dp . The max. height of the modal corresponds to the height of the current viewport. Default: 600 options.width? number Sets the width of the modal, in dp . The max. width of the modal corresponds to the width of the current viewport. Default: 800 options.fullScreen? boolean Set it to: false to disallow full screen display for the modal. true to override height and width , and to display the modal in full screen. Default: false options.data? any Any data that you want to pass directly to the modal and use it inside the modal itself. Check the getModalData() method. getModalData(...) () =&gt; Promise&lt;undefined | Data&gt; Retrieves the data associated with the currently open modal in the Miro board. This data is initially passed to the modal when it is opened using the miro.board.ui.openModal({ data, ... }) method. This method is typically called from within the modal itself to access any data that it needs to function correctly. If no data was passed when the modal was opened, calling getModalData will return a promise that resolves to undefined . Note: getModalData will always return promise that resolves or to undefined or to the actual passed data. Example: Consider the following scenario where a modal is opened with some data: TypeScript // Define some data to pass to the modal const someData = { message: &quot;my message&quot; }; // Open a modal and pass the data to it const { waitForClose } = await miro.board.ui.openModal&lt;{message: string}, string&gt;({ data: someData, url: &quot;show-this-page-in-the-modal.html&quot;, width: 600, height: 400, fullscreen: false, }); Now, from within the modal, you can retrieve this data using getModalData() : TypeScript // Retrieve the data from within the modal const data = await miro.board.ui.getModalData&lt;{message: string}&gt;() console.log(data) // Outputs: &quot;{ message: &quot;my message&quot; }&quot; closeModal(...) (result?: Result) =&gt; Promise&lt;void&gt; Closes an open modal on the current board. This method accepts an optional result parameter. Providing this parameter results in the modal being resolved with the provided value. If you use the waitForClose() method‚Äîreturned by miro.board.ui.openModal(...) ‚Äîthe promise returned by waitForClose() will resolve, returning the value of result . TLDR; If you&#x27;ve passed a result value and close the modal, this value will be returned by the waitForClose() promise. This is useful if you want to perform some action based on the result after the modal is closed. ‚ÑπÔ∏è Note: To close an open modal, closeModal must be executed after openModal . The app that closes the modal with closeModal must be the same app that opened it with openModal . Example: TypeScript // Open a modal await miro.board.ui.openModal({ url: &#x27;show-this-page-in-the-modal.html&#x27;, height: 400, width: 600, fullscreen: false, }); // Close the open modal await miro.board.ui.closeModal(); // Open a modal and wait for the result const {waitForClose} = await miro.board.ui.openModal({ url: &#x27;show-this-page-in-the-modal.html&#x27;, height: 400, width: 600, fullscreen: false, }); async function logResult() { const result = await waitForClose(); console.log(result) // This will log: &quot;Hello world!&quot; } logResult() // Close the open modal with some result await miro.board.ui.closeModal(&quot;Hello world!&quot;); on(...) (event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void) =&gt; void on property TypeScript miro.board.ui.on(event, handler); If you want your app to react to an event by executing a function, you can use the on property to subscribe to events. The on property subscribes the app to listen to an event. When the event fires, the event handler executes a function to perform an action. To subscribe to an event and its handler, pass to the on property: The event that your app should listen to. The event handler that the app needs to call when the event fires. üí° To unsubscribe from an event and its handler, use the off property. Supported events Event type Event handler Event fires when... drop (event: DropEvent) An HTML element is dropped from an open panel to the board. See also Add drag and drop to your app . icon:click () An app icon is clicked. See also Add clicking on an icon to your app . app_card:open (event: AppCardOpenEvent) The app card status icon is connected , the icon is clicked, and it enables opening a modal with the app card detail view. app_card:connect (event: AppCardConnectEvent) The app card status icon is disconnected , the icon is clicked, and it enables connecting an app card with a corresponding data source. selection:update (event: SelectionUpdateEvent) An area on the board is selected. online_users:update (event: OnlineUsersUpdateEvent) The number of currently online board users changes. items:create (event: ItemsCreateEvent) New items are created on the board. experimental:items:update (event: ItemsUpdateEvent) Existing items are updated on the board. items:delete (event: ItemsDeleteEvent) Existing items are deleted from the board. custom:${string} (event: CustomEvent) A custom action on a board item is initiated. Dispatching events In general, when an app subscribes to an event, the event is dispatched to all iframes : Headless (main iframe) Panel Modal This behavior makes it easy to subscribe to an event from any of these iframes, without worrying about which iframe the event is dispatched to. ‚ÑπÔ∏è Note: icon:click is dispatched only to the headless/main iframe . Typically, icon:click is used to open a panel or a modal when a user clicks the app icon on the app toolbar or the app toolbar panel. drop event TypeScript on(event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void): void When an app subscribes to this event, it&#x27;s dispatched to all iframes . drop registers the event associated with dropping one or more selected items on the board. The event handler has the following properties: Property Type Description x Number Coordinate that defines the horizontal position of the HTML element to drop on the board. y Number Coordinate that defines the vertical position of the HTML element to drop on the board. target Element interface The HTML element that is the recipient of the drop event. Example: TypeScript /** When the selected HTML element is dropped on the board: * 1. A sticky note is created. * 2. The text of the HTML element is assigned to the * &#x27;content&#x27; property of sticky note. */ miro.board.ui.on(&#x27;drop&#x27;, async ({x, y, target}) =&gt; { await miro.board.createStickyNote({ x, y, content: target.innerText, }); }); You can provide a custom preview image for drag &amp; drop using data attributes on elements with class=&quot;miro-draggable&quot; : data-drag-preview - Specify the URL of the preview image to use during dragging. data-drag-preview-width - (Optional) Set the width of the preview image in pixels. data-drag-preview-height - (Optional) Set the height of the preview image in pixels. Preview image size behavior: If no width or height is set, the original image size will be used. If only width or height is set, that dimension will be used and the other dimension will be calculated to maintain aspect ratio. If both width and height are set, those dimensions will be applied and aspect ratio will be ignored. A valid URL pointing to or representing the image. Possible formats: A publicly available, absolute URL to an image. A base64-encoded data URL : data:image/&lt;image-file-format&gt;;base64,&lt;base64-encoded-image&gt; . Example: HTML &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;My panel with draggable items&lt;/title&gt; &lt;!-- Loads the Miro Web SDK --&gt; &lt;script src=&quot;https://miro.com/app/static/sdk/v2/miro.js&quot;&gt;&lt;/script&gt; &lt;!-- Loads the companion JS file with the logic --&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- The &#x27;miro-draggable&#x27; class makes HTML items draggable --&gt; &lt;!-- The `data-drag-preview` attribute changes preview image during dragging of element --&gt; &lt;div class=&quot;miro-draggable&quot; data-drag-preview=&quot;https://amazing-images.com/categories/cats/cute-fluffy-kitten.png&quot;&gt; Kitten &lt;/div&gt; &lt;!-- The `data-drag-preview-width` attribute changes preview image width. The `data-drag-preview-height` will work in the same way --&gt; &lt;div class=&quot;miro-draggable&quot; data-drag-preview-width=&quot;100&quot; data-drag-preview=&quot;https://amazing-images.com/categories/dogs/beautiful-dog.jpg&quot; &gt; Dog &lt;/div&gt; &lt;!-- The `data-drag-preview-width` + `data-drag-preview-height` force apply size and ignore aspect ratios of image --&gt; &lt;div class=&quot;miro-draggable&quot; data-drag-preview-width=&quot;100&quot; data-drag-preview-height=&quot;100&quot; data-drag-preview=&quot;https://amazing-images.com/categories/dragons/scary-dragon.svg&quot; &gt; Dragon &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; icon:click event TypeScript on(event: &#x27;icon:click&#x27;, handler: () =&gt; void) =&gt; void When an app subscribes to this event, it&#x27;s dispatched only to the headless/main iframe . icon:click registers click events on icons. When a user clicks an icon, the registered event handler for icon:click is called. Typically, icon:click is used to open a panel , or to display a modal . Example: TypeScript /** When a user clicks the icon: * 1. The openPanel method is called * 2. The method opens the HTML page: `panel.html` */ miro.board.ui.on(&#x27;icon:click&#x27;, async () =&gt; { await miro.board.ui.openPanel({ url: &#x27;panel.html&#x27;, }); }); app_card:open event TypeScript on(event: &#x27;app_card:open&#x27;, handler: (event: AppCardOpenEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . app_card:open registers click events to open an app card from compact to detail view. When a user clicks the icon to expand an app card to view it in detail, the registered event handler for app_card:open is called. Typically, app_card:open is used to open a modal displaying the custom fields of the app card and their content. Example: TypeScript /** When a user clicks the icon that expands an app card to view it in detail: * 1. The &#x27;openModal&#x27; method is called * 2. The method opens a modal to display the specific app card content fetched from the URL */ // Listen to the &#x27;app_card:open&#x27; event miro.board.ui.on(&#x27;app_card:open&#x27;, (event) =&gt; { console.log(&#x27;Subscribed to app card open event&#x27;, event); const {appCard} = event; // Build a URL containing the app card ID. // You pass this URL with the &#x27;openModal()&#x27; method below. // The code in the modal uses the &#x27;appCardId&#x27; URL query parameter // to identify which app card was opened. const url = `https://my.app.example.com/modal.html?appCardId=${appCard.id}`; // Open the modal to display the content of the fetched app card miro.board.ui.openModal({ url, }); }); app_card:connect event TypeScript on(event: &#x27;app_card:connect&#x27;, handler: (event: AppCardConnectEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . By default, newly created app cards have a disconnected status, unless the app card constructor sets a different value. To connect an app card to a corresponding data source in an external application, an app must listen to the app_card:connect event. When an app listens to the app_card:connect event: The disconnected icon is clickable. On hovering over the icon, a tooltip is displayed to notify users that they can click the icon to connect the app card to a data source. When users click the icon, the app_card:connect event fires. The event handler needs to include at least the logic to: Retrieve the data source that the app card maps to. Sync data to populate the app card fields with any updated information. Update the app card status from disconnected to connected . sync() the app card to propagate the changes to the board. If the app listens also to the app_card:open event, it can react to it; typically, by opening a modal to display the app card detail view. Example: TypeScript /** In a typical flow: * 1. The app creates an app card. * The &#x27;disconnected&#x27; status icon is not clickable, yet. * 2. The app listens to the &#x27;app_card:connect&#x27; event. * The &#x27;disconnected&#x27; status icon is clickable. * 3. The app listens to the &#x27;app_card:open&#x27; event. * 4. When users click the &#x27;disconnected&#x27; status icon, a tooltip prompts them to connect the app card to its data source. * 5. When the app card is connected, its status icon changes to &#x27;connected&#x27;. * 6. Now the app can open a modal to display the app card detail view. */ // Create an app card const appCard = await miro.board.createAppCard({ title: &#x27;This is the title of the app card&#x27;, // Default status of new app cards status: &#x27;disconnected&#x27;, }); // Listen to the &#x27;app_card:connect&#x27; event miro.board.ui.on(&#x27;app_card:connect&#x27;, (event) =&gt; { console.log(&#x27;Connect the app card to its data source&#x27;); const appcard = event.appCard; // Update the app card status to &#x27;connected&#x27; appcard.status = &#x27;connected&#x27;; // Propagate the app card updates to the board appcard.sync(); }); // Listen to the &#x27;app_card:open&#x27; event miro.board.ui.on(&#x27;app_card:open&#x27;, (event) =&gt; { console.log(&#x27;Subscribed to app card open event&#x27;, event); // URL containing the app card ID. // The content is displayed inside the modal const url = `https://my.app.example.com/modal.html?appCardId=${appCard.id}`; // Open the modal to display the content of the fetched app card miro.board.ui.openModal({ url, }); }); Figure 1. Newly created card, or duplicate app card through manual copying and pasting on the board UI. The app card status is disconnected. The tooltip notifies about the missing connection. The status icon isn&#x27;t clickable. Figure 2. The app card status is disconnected . The tooltip prompts to connect it to its data source. The status icon is clickable. Figure 3. The app card status is connected . The app listens to the app_card:open event. When the icon is clicked, the event fires. Typically, it opens a modal to display the app card detail view. selection:update event TypeScript on(event: &#x27;selection:update&#x27;, handler: (event: SelectionUpdateEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . selection:update registers the event associated with updating the content of the current selection on the board. When a user selects an area on the board, the registered event handler for selection:update is called. The event contains an array with the selected board items. If the selected area doesn&#x27;t include any board items, the array is empty. If the grouped items are selected, the group entity for those items will also be returned. When individual items within a group are selected with a double-click, the group entity will not be returned as part of this method. You can add logic to perform actions on the selection, such as filtering specific item types, and then modifying them. Example: TypeScript /** When a user clicks and selects multiple board items on a board: * 1. The &#x27;selection:update&#x27; method logs the selection to the developer console * 2. A filter identifies sticky note items in the selection * 3. The color of the sticky notes is changed to &#x27;cyan&#x27; */ // Listen to the &#x27;selection:update&#x27; event miro.board.ui.on(&#x27;selection:update&#x27;, async (event) =&gt; { console.log(&#x27;Subscribed to selection update event&#x27;, event); console.log(event.items); const selectedItems = event.items; // Filter sticky notes from the selected items const stickyNotes = selectedItems.filter((item) =&gt; item.type === &#x27;sticky_note&#x27;); // Change the fill color of the sticky notes for (const stickyNote of stickyNotes) { stickyNote.style.fillColor = &#x27;cyan&#x27;; await stickyNote.sync(); } }); online_users:update event TypeScript on(event: &#x27;online_users:update&#x27;, handler: (event: OnlineUsersUpdateEvent) =&gt; void): void When an app subscribes to this event, it&#x27;s dispatched to all iframes . online_users:update registers the event associated with a change in the number of users that are currently online on the board. When a user joins or leaves the board, the registered event handler for online_users:update is called. The event contains an array with user IDs and names of the online users. Your app can include logic to perform follow-up actions based on the change in online users. For example, it can greet a new user that just joined the board. Example: TypeScript /** When the number of online users changes, identify the * new online users and greet them with a notification. */ let currentOnlineUsers = []; // Listen to the &#x27;online_users:update&#x27; event. await miro.board.ui.on(&#x27;online_users:update&#x27;, async (event) =&gt; { console.log(&#x27;Subscribed to the update of online users&#x27;); console.log(&#x27;Online users: &#x27;, event.users); const onlineUsers = event.users; // Identify the new online users. const newUsers = onlineUsers.filter((user) =&gt; !currentOnlineUsers.find((u) =&gt; u.id === user.id)); console.log(&#x27;New users:&#x27;, newUsers); // Greet the new online users. for (const newUser of newUsers) { await miro.board.notifications.showInfo(`Hello, ${newUser.name}!`); } currentOnlineUsers = onlineUsers; }); items:create event TypeScript on(event: &#x27;items:create&#x27;, handler: (event: ItemsCreateEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . items:create registers the event associated with the creation of a new item on the board. When a user creates a new item on a board, the registered event handler for items:create is called. The event contains an array with the created board items. Your app can include logic to perform follow-up actions on the created items. For example, it can filter specific item types, and then process them by fetching or setting their properties. ‚ÑπÔ∏è Note: When creating a new item by copy-pasting or by duplicating an existing one, items:create isn&#x27;t triggered. Example: TypeScript /** When a user creates a new item on a board: * 1. &#x27;items:create&#x27; logs the created items to the developer console. * 2. In the group of created items, a filter identifies sticky notes. * 3. The color of the sticky notes is set to &#x27;cyan&#x27;. */ // Listen to the &#x27;items:create&#x27; event. miro.board.ui.on(&#x27;items:create&#x27;, async (event) =&gt; { console.log(&#x27;Subscribed to the creation of new board items&#x27;, event); console.log(event.items); const createdItems = event.items; // Filter sticky notes from the created items. const stickyNotes = createdItems.filter((item) =&gt; item.type === &#x27;sticky_note&#x27;); // Change the fill color of the sticky notes. for (const stickyNote of stickyNotes) { stickyNote.style.fillColor = &#x27;cyan&#x27;; await stickyNote.sync(); } }); Experimental experimental:items:update event TypeScript on(event: &#x27;experimental:items:update&#x27;, handler: (event: ItemsUpdateEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . experimental:items:update registers the event associated with updating an item on the board. When a user updates one or more items on the board, the registered event handler for experimental:items:update is called. The event contains an array with the updated board items. Your app can include logic to perform follow-up actions on the updated items. For example, it can log a list of the updated board items. ‚ÑπÔ∏è Note: Currently, experimental:items:update fires only when items are moved on the board, when an item dimensions are resized , when an item is rotated on the board, and when updating the scale of an item. In the future, the event will also fire when updating other item data. Example: TypeScript /** * When a user updates one or more items on the board: * &#x27;experimental:items:update&#x27; logs all the updated board items to the developer console. */ // Listen to the &#x27;experimental:items:update&#x27; event. miro.board.ui.on(&#x27;experimental:items:update&#x27;, async (event) =&gt; { console.log(&#x27;Subscribed to updates of board items&#x27;, event); console.log(&#x27;Updated items: &#x27;, event.items); }); items:delete event TypeScript on(event: &#x27;items:delete&#x27;, handler: (event: ItemsDeleteEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . items:delete registers the event associated with deleting an item from the board. When a user deletes one or more items from the board, the registered event handler for items:delete is called. The event contains an array with the deleted board items. Your app can include logic to perform follow-up actions on the deleted items. For example, it can log a list of the deleted board items. Example: TypeScript /** * When a user deletes one or more items from the board: * &#x27;items:delete&#x27; logs all deleted board items to the developer console. */ // Listen to the &#x27;items:delete&#x27; event. miro.board.ui.on(&#x27;items:delete&#x27;, async (event) =&gt; { console.log(&#x27;Subscribed the deletion of board items&#x27;, event); console.log(&#x27;Deleted items: &#x27;, event.items); }); custom:${string} event TypeScript on(event: `custom:${string}`, handler: (event: CustomEvent) =&gt; void): void; When an app subscribes to this event, it&#x27;s dispatched to all iframes . custom:${string} events implement custom actions in an app. Web SDK custom actions behave like standard Web SDK events : The app subscribes to a custom action event with the on property . When the custom action event is no longer necessary, the app unsubscribes from it with the off property . Custom event naming Custom event names always start with the custom: prefix: custom:${string} ${string} must match the value assigned to the event property when the app registers the custom action with the miro.board.experimental.action.register method. The event name can contain only lowercase alphabetic characters and hyphens ( ^[a-z]+(-[a-z]+)\*$ ). It cannot contain spaces. It cannot be longer than 30 characters. off(...) (event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void) =&gt; void off property TypeScript miro.board.ui.off(event, handler); When an app no longer needs to listen to an event to trigger an event handler, it can use the off property to unsubscribe from it. To unsubscribe from an event and its handler, pass to the off property: The event whose handler you want your app to unsubscribe from. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. üí° To subscribe to an event and its handler, use the on property. Supported events See the supported events for the on property . drop unsubscribe TypeScript off(event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void): void Enables unsubscribing from a drop event handler. To unsubscribe, pass to the off property: The drop event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add a &#x27;drop&#x27; event handler to drag and drop images. const drop = async (event: DropEvent) =&gt; { const {x, y, target} = event; if (target instanceof HTMLImageElement) { const image = await miro.board.createImage({ x, y, url: target.src, }); } }; // Register the &#x27;drop&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;drop&#x27;, drop); // Unsubscribe from the &#x27;drop&#x27; handler. // The app no longer creates image items on drag and drop. miro.board.ui.off(&#x27;drop&#x27;, drop); icon:click unsubscribe TypeScript off(event: &#x27;icon:click&#x27;, handler: () =&gt; void) =&gt; void Enables unsubscribing from an icon:click event handler. To unsubscribe, pass to the off property: The icon:click event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add an &#x27;iconClick&#x27; event handler to open a panel upon clicking an icon. const iconClick = async () =&gt; { await miro.board.ui.openPanel({ url: &#x27;panel.html&#x27;, }); }; // Register the &#x27;icon:click&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;icon:click&#x27;, iconClick); // Unsubscribe from the &#x27;icon:click&#x27; event handler. // The app no longer enables opening a panel when clicking an icon. miro.board.ui.off(&#x27;icon:click&#x27;, iconClick); app_card:open unsubscribe TypeScript off(event: &#x27;app_card:open&#x27;, handler: (event: AppCardOpenEvent) =&gt; void): void; Enables unsubscribing from an app_card:open event handler. To unsubscribe, pass to the off property: The app_card:open event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Create an app card. const appCard = await miro.board.createAppCard({ title: &#x27;This is the title of the app card&#x27;, status: &#x27;disconnected&#x27;, }); // Add an &#x27;appCardOpen&#x27; event handler for the &#x27;app_card:open&#x27; event. const appCardOpen = async (event: AppCardOpenEvent) =&gt; { const appcard = event.appCard; const url = `https://my.app.example.com/modal.html?appCardId=${appCard.id}`; miro.board.ui.openModal({ url, }); }; // Register the &#x27;app_card:open&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;app_card:open&#x27;, appCardOpen); // Unsubscribe from the &#x27;app_card:open&#x27; event handler. // The app no longer enables opening a modal with the detail view of an app card. miro.board.ui.off(&#x27;app_card:open&#x27;, appCardOpen); app_card:connect unsubscribe TypeScript off(event: &#x27;app_card:connect&#x27;, handler: (event: AppCardConnectEvent) =&gt; void): void; Enables unsubscribing from the app_card:connect event and its handler. To unsubscribe, pass to the off property: The app_card:connect event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Create an app card. const appCard = await miro.board.createAppCard({ title: &#x27;This is the title of the app card&#x27;, status: &#x27;disconnected&#x27;, }); // Add an &#x27;appCardConnect&#x27; event handler for the &#x27;app_card:connect&#x27; event. const appCardConnect = async (event: AppCardConnectEvent) =&gt; { const appcard = event.appCard; appcard.status = &#x27;connected&#x27;; appcard.sync(); }; // Register the &#x27;app_card:connect&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;app_card:connect&#x27;, appCardConnect); // Unsubscribe from the &#x27;app_card:connect&#x27; event handler. // The app no longer enables connecting an app card to a data source. miro.board.ui.off(&#x27;app_card:connect&#x27;, appCardConnect); selection:update unsubscribe TypeScript off(event: &#x27;selection:update&#x27;, handler: (event: SelectionUpdateEvent) =&gt; void): void; Enables unsubscribing from a selection:update event handler. To unsubscribe, pass to the off property: The selection:update event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add a &#x27;selectionUpdate&#x27; event handler to update the color of sticky notes included in a selection. const selectionUpdate = async (event: SelectionUpdateEvent) =&gt; { const selectedItems = event.items; const stickyNotes = selectedItems.filter((item) =&gt; item.type === &#x27;sticky_note&#x27;); for (const stickyNote of stickyNotes) { stickyNote.style.fillColor = &#x27;cyan&#x27;; await stickyNote.sync(); } }; // Register the &#x27;selection:update&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;selection:update&#x27;, selectionUpdate); // Unsubscribe from the &#x27;selection:update&#x27; event handler. // The app no longer enables updating the color of the sticky notes included in a selection to cyan. miro.board.ui.off(&#x27;selection:update&#x27;, selectionUpdate); online_users:update unsubscribe TypeScript off(event: &#x27;online_users:update&#x27;, handler: (event: OnlineUsersUpdateEvent) =&gt; void): void Enables unsubscribing from an online_users:update event handler. To unsubscribe, pass to the off property: The online_users:update event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add an &#x27;online_users:update&#x27; event handler to greet new online users joining the board. let currentOnlineUsers = []; const onlineUsersUpdate = async (event) =&gt; { const onlineUsers = event.users; const newUsers = onlineUsers.filter((user) =&gt; !currentOnlineUsers.find((u) =&gt; u.id === user.id)); for (const newUser of newUsers) { await miro.board.notifications.showInfo(`Hello, ${newUser.name}!`); } currentOnlineUsers = onlineUsers; }; // Register the &#x27;online_users:update&#x27; event so that the app listens to it. await miro.board.ui.on(&#x27;online_users:update&#x27;, onlineUsersUpdate); // Unsubscribe from the &#x27;online_users:update&#x27; event handler. // The app no longer greets new online users. await miro.board.ui.off(&#x27;online_users:update&#x27;, onlineUsersUpdate); items:create unsubscribe TypeScript off(event: &#x27;items:create&#x27;, handler: (event: ItemsCreateEvent) =&gt; void): void; Enables unsubscribing from an items:create event handler. To unsubscribe, pass to the off property: The items:create event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add an &#x27;itemsCreate&#x27; event handler to update the color of user-created sticky notes. const itemsCreate = async (event: ItemsCreateEvent) =&gt; { const createdItems = event.items; const stickyNotes = createdItems.filter((item) =&gt; item.type === &#x27;sticky_note&#x27;); for (const stickyNote of stickyNotes) { stickyNote.style.fillColor = &#x27;cyan&#x27;; await stickyNote.sync(); } }; // Register the &#x27;items:create&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;items:create&#x27;, itemsCreate); // Unsubscribe from the &#x27;items:create&#x27; event handler. // The app no longer updates the color of user-created sticky notes. miro.board.ui.off(&#x27;items:create&#x27;, itemsCreate); Experimental experimental:items:update unsubscribe TypeScript off(event: &#x27;experimental:items:update&#x27;, handler: (event: ItemsUpdateEvent) =&gt; void): void; Enables unsubscribing from an experimental:items:update event handler. To unsubscribe, pass to the off property: The experimental:items:update event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add an &#x27;itemsUpdate&#x27; event handler to log user-updated board items to the developer console. const itemsUpdate = async (event: ItemsUpdateEvent) =&gt; { console.log(event.items); }; // Register the &#x27;experimental:items:update&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;experimental:items:update&#x27;, itemsUpdate); // Unsubscribe from the &#x27;experimental:items:update&#x27; event handler. // The app no longer enables logging user-updated board items. miro.board.ui.off(&#x27;experimental:items:update&#x27;, itemsUpdate); items:delete unsubscribe TypeScript off(event: &#x27;items:delete&#x27;, handler: (event: ItemsDeleteEvent) =&gt; void): void; Enables unsubscribing from an items:delete event handler. To unsubscribe, pass to the off property: The items:delete event. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. Example: TypeScript // Add an &#x27;itemsDelete&#x27; event handler to log user-deleted board items to the developer console. const itemsDelete = async (event: ItemsDeleteEvent) =&gt; { console.log(event.items); }; // Register the &#x27;items:delete&#x27; event so that the app listens to it. miro.board.ui.on(&#x27;items:delete&#x27;, itemsDelete); // Unsubscribe from the &#x27;items:delete&#x27; event handler. // The app no longer enables logging user-deleted board items. miro.board.ui.off(&#x27;items:delete&#x27;, itemsDelete); custom:${string} event TypeScript off(event: `custom:${string}`, handler: (event: CustomEvent) =&gt; void): void; Enables unsubscribing from a custom event handler. To unsubscribe, pass to the off property: The custom:${event} event that you want your app to unsubscribe from. The event handler that you previously registered with the on property, and that your app no longer needs to listen to. All properties Property Type canOpenModal(...) () =&gt; Promise&lt;boolean&gt; canOpenPanel(...) () =&gt; Promise&lt;boolean&gt; closeModal(...) (result?: Result) =&gt; Promise&lt;void&gt; closePanel(...) (result?: Result) =&gt; Promise&lt;void&gt; getModalData(...) () =&gt; Promise&lt;undefined | Data&gt; getPanelData(...) () =&gt; Promise&lt;undefined | Data&gt; off(...) (event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void) =&gt; void on(...) (event: &#x27;drop&#x27;, handler: (event: DropEvent) =&gt; void) =&gt; void openModal(...) ( options: Identity&lt;{ fullscreen?: boolean; height ?: number; title =&quot;url&quot;&gt;url: string; width ?: number } &amp; conditional&gt; ) =&gt; Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt; openPanel(...) ( options: Identity&lt;{ height ?: number; title =&quot;url&quot;&gt;url: string } &amp; conditional&gt; ) =&gt; Promise&lt;{ waitForClose: () =&gt; Promise&lt;Result | undefined&gt; }&gt; Updated about 1 year ago Table of Contents Methods canOpenPanel(...) openPanel(...) getPanelData(...) closePanel(...) canOpenModal(...) openModal(...) getModalData(...) closeModal(...) on(...) off(...) All properties